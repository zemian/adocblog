package com.zemian.adocblog.data.dao;

import com.zemian.adocblog.data.domain.AuditLog;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * A DAO to access AuditLog domain.
 *
 * This class is generated by TableToJava on Dec 23, 2017.
 */
@Repository
public class AuditLogDAO extends AbstractDAO {

    public static class AuditLogRowMapper implements RowMapper<AuditLog> {
        @Override
        public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
            AuditLog ret = new AuditLog();
            ret.setLogId((Integer) rs.getObject("log_id"));
            ret.setName((String) rs.getObject("name"));
            ret.setValue((String) rs.getObject("value"));
            ret.setCreatedDt(rs.getTimestamp("created_dt").toLocalDateTime());
            return ret;
        }
    }

    private static Logger LOG = LoggerFactory.getLogger(AuditLogDAO.class);

    public AuditLog create(String name, String value) {
        AuditLog a = new AuditLog();
        a.setName(name);
        a.setValue(value);
        a.setCreatedDt(LocalDateTime.now());
        create(a);
        return a;
    }

    public void create(AuditLog auditLog) {
        String sql = "INSERT INTO audit_logs(name, value, created_dt) VALUES(?, ?, ?)";
        KeyHolder keyHolder = new GeneratedKeyHolder();
        int ret = jdbc.update((conn) -> {
            PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
            int idx = 1;
            pstmt.setObject(idx++, auditLog.getName());
            pstmt.setObject(idx++, auditLog.getValue());
            pstmt.setObject(idx++, auditLog.getCreatedDt());
            return pstmt;
        }, keyHolder);

        // Retrieve and save the generate key
        auditLog.setLogId((Integer)keyHolder.getKeys().get("log_id"));
        LOG.info("Inserted {}, result={}", auditLog, ret);
    }

    public void update(AuditLog auditLog) {
        String sql = "UPDATE audit_logs SET" +
                " name = ?," +
                " value = ?," +
                " created_dt = ?" +
                " WHERE log_id = ?";
        int ret = jdbc.update(sql,
                auditLog.getName(),
                auditLog.getValue(),
                auditLog.getCreatedDt(),
                auditLog.getLogId());
        LOG.debug("Updated {}, result={}", auditLog, ret);
    }

    public AuditLog get(Integer logId) {
        String sql = "SELECT * FROM audit_logs WHERE log_id = ?";
        return jdbc.queryForObject(sql, new AuditLogRowMapper(), logId);
    }

    public void delete(Integer logId) {
        int ret = jdbc.update("DELETE FROM audit_logs WHERE log_id = ?", logId);
        LOG.debug("Deleted AuditLog logId={}, result={}", logId, ret);
    }

    public List<AuditLog> findAll() {
        String sql = "SELECT * FROM audit_logs ORDER BY log_id";
        return jdbc.query(sql, new AuditLogRowMapper());
    }

    public boolean exists(Integer logId) {
        String sql = "SELECT EXISTS(SELECT log_id FROM audit_logs WHERE log_id = ?)";
        return jdbc.queryForObject(sql, Boolean.class, logId);
    }

    public PagingList<AuditLog> find(Paging paging) {
        String sql = "SELECT * FROM audit_logs ORDER BY log_id";
        return findByPaging(sql, new AuditLogRowMapper(), paging);
    }

    public int removeOldLogs(LocalDateTime olderDt) {
        String sql = "DELETE FROM audit_logs WHERE created_dt <= ?";
        int ret = jdbc.update(sql, olderDt);
        LOG.debug("Deleted records older than {}, result={}", olderDt, ret);
        return ret;
    }
}
